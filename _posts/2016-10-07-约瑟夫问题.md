---
layout: post
title: 约瑟夫问题
tags:
- 数据结构
- 算法
- 约瑟夫问题
categories: 数据结构
description: Josephus问题是以弗拉维奥·约瑟夫斯命名的,它是一世纪的一名犹太历史学家.
---
> Josephus问题是以弗拉维奥·约瑟夫斯命名的,它是一世纪的一名犹太历史学家.

## 约瑟夫问题的由来
- Josephus在自己的日记中写道:
    1. 在罗马人占领乔塔帕特后,39个犹太人与Josephus及他的朋友躲到一个洞中,39个犹太人决定宁愿死也不要被敌人抓到,于是决定了一个自杀方式.
    2. 自杀方式的约定:
        1. 41个人排成一个圆圈,由第1个人开始报数,每报数到第3人该人就必须自杀,然后再由下一个重新报数,直到所有人都自杀身亡为止.
        2. Josephus要他的朋友先假装遵从,他将朋友与自己安排在第16个与第31个位置,于是逃过了这场死亡游戏,
    3. 后传:
        1. 瑟夫斯说服了他的朋友,他们将向罗马军队投降,不再自杀.

## 约瑟夫问题
- Josephus问题描述:对于任意给定的n,s和m,求按出列次序得到的人员序列.
    1. n:参与游戏的人数,每个人的信息
    2. s:开始的人
    3. m:单次计数
    4. code

    ```cpp
    #include <stdio.h>
    #include <stdlib.h>

    struct link {
        int index;
        struct link *next;
    };

    int main(int argc, const char * argv[]) {
        int sum, cycle;
        scanf("%d %d", &sum, &cycle);
        struct link *head = (struct link*)malloc(sizeof(struct link));
        head->index = 1;
        head->next = NULL;
        struct link *tmp = head;
        struct link *tmpNew = NULL;
        int i = 0;
        for (i = 2; i <= sum; ++i) {
            tmpNew = (struct link*)malloc(sizeof(struct link));
            tmpNew->index = i;
            tmpNew->next = NULL;
            tmp->next = tmpNew;
            tmp = tmpNew;
        }
        tmp->next = head;
        tmp = head;
        i = 1;
        while (1) {
            ++i;
            tmpNew = tmp->next;
            if (tmpNew == tmpNew->next) {
                break;
            }
            if (0 == i % cycle) {
                tmp->next = tmpNew->next;
                tmp = tmpNew->next;
                free(tmpNew);
                i = 1;
            } else {
                tmp = tmp->next;
            }
        }
        printf("%d\n", tmpNew->index);
        return 0;
    }
    ```
