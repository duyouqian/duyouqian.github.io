---
layout: post
title: 线性结构
tags:
- 数据结构
- 线性结构
categories: 数据结构
description: 线性表是零个或多个元素的有穷序列.
---

> **线性结构**包含线性表,顺序表,链表逻辑结构.

## 一.线性表

- 线性表简称表,是零个或多个元素的有穷序列,通常可以表示成$k_{0},k_{1},...,k_{n-1}(n\geq{1})$
    1. 表目:线性表中的元素(可包含对个数据项,记录),通常是同类型的
    2. 索引(下标):i称为表目$k_{i}$的索引或下标
    3. 表的长度:线性表中所含元素的个数n
    4. 空表:长度为零的线性表(n=0)

- 线性表的特点:
    1. 操作灵活,其长度可以增长,缩短
    2. 对于小规模的应用是非常高效的

- 线性表的结构:
    - 二元组$B=(K,R) K={a_{0}, a_{1}, ..., a_{n-1}} R={r}$
        1. 有一个唯一的开始结点(头结点),它没有前驱,有一个唯一的直接后继
        2. 有一个唯一的终止结点(尾结点),它有一个唯一的直接前驱,而没有后继
        3. 其他的结点称为内部结点,每个内部结点都有且仅有一个唯一的直接前驱和直接后继,即$$\langle a_{i}, a_{i+1}\rangle a_{i}是a_{i+1}的前驱, a_{i+1}是a_{i}的后继$$
        4. 前驱/后继关系r,具有反对称性和传递性.
    - 特点:
        1. 均匀性:对于同一线性表的各数据元素必定具有相同的数据类型和长度.
        2. 有序性:各数据元素在线性表中都有自己的位置,且数据元素之间的相对位置是线性的.
    - 按复杂程度划分:
        1. 简单的:线性表,栈,队列,散列表
        2. 复杂的:广义表,多维数组,文件等
    - 按访问方式划分:
        1. 直接访问型(direct access):数组
        2. 顺序访问型(sequential access):链表
        3. 目录索引型(directory access):散列表
    - 按操作划分:
        1. 线性表
            1. 所有表目都是同一类型结点的线性表
            2. 不限制操作形式
            3. 根据存储的不同分为:顺序表,链表
        2. 栈(LIFO)
            1. 插入和删除操作都限制在表的同一端进行
        3. 队列(FIFO)
            1. 插入操作在表的一端,删除操作在另一端
    - 逻辑结构
        1. 主要属性
            1. 线性表的长度(预留存储,数据规模)
            2. 表头(head)
            3. 表尾(tail)
            4. 当前位置(current position)(先定位,再操作)
    - 存储结构
        1. 顺序表
            1. 按索引值从小到大存放在一片相邻的连续区域
            2. 紧凑结构,存储密度为1(物理关系<=>逻辑关系)
        2. 链表(需要额外的存储来存储指针)
            1. 单链表
            2. 双链表
            3. 循环链表
    - 运算
        1. 建立线性表
        2. 清除线性表
        3. 插入一个新元素
        4. 删除某个元素
        5. 修改某个元素
        6. 排序
        7. 检索
    - 模板

        ```cpp
        template <class T> 
        class List {
        public:
            void clear();
            bool isEmpty();
            bool append(const T value);
            bool insert(const int p, const T value);
            bool delete(const int p);
            bool getPos(int& p, const T value);
            bool getValue(const int p, T& value);
            bool setValue(const int p, const T value);
        };
        ```

## 二.顺序表
> **顺序表**也称向量,采用定长的一维数组存储结构

- 主要特性:
    1. 元素的类型相同
    2. 元素顺序的存储在连续存储空间中,每一个元素有唯一的索引值
    3. 使用常数作为向量长度
- 数组存储
- 读写其元素方便,通过下标即可制定位置
    1. 只要确定了首地址,线性表中任意数据元素都可以随机存取
- 元素地址计算如下:$$Loc(k_{i})=Loc(k_{0})+c*i, c=sizeof(ELEM)$$
- 类定义

    ```cpp
    class ArrList : public List<T> {
    private:
        T *_list;
        int32_t _maxSize;
        int32_t _curLen;
        int32_t _position;
    public:
        ArrList(const int size);
        ~ArrayList();
    }
    template <class T>
    ArrList::ArrList(const int size) : _maxList(size) {
        _list = new T[size];
        _curLen = _position = 0;
    }
    template <class T>
    ArrList::~ArrList() {
        delete []_list;
    }
    template <class T>
    void ArrList::clear() {
        delete []_list;
        _curLen = _position = 0;
        _list = new T[_maxSize];
    }
    template <class T>
    bool ArrList::insert(const int p, const T value) {
        if (p >= _maxSize) {
            fprintf(stderr, "The list is overflow\n");
            return false;
        }
        if (p < 0 || p > _curLen) {
            fprintf(stderr, "Insertion point is illegal\n");
            return false;
        }
        for (int32_t i = _curLen; i > p; --i) {
            _list[i] = _list[i - 1];
        }
        _list[p] = value;
        ++_curLen;
        return true;
    }
    template <class T>
    bool ArrList::delete(const int p) {
        if (_curLen <= 0) {
            fprintf(stderr, "No element to delete\n");
            return false;
        }
        if (p < 0 || p >= _curLen) {
            fprintf(stderr, "deletion is illegal\n");
            return false;
        }
        for (int32_t i = p, end = _curLen - 1; i < end; ++i) {
            _list[i] = _list[i + 1];
        }
        --_curLen;
        return true;
    }
    ```
- 时间复杂度分析
    1. 元素移动
        1. 插入: 移动n - i
        2. 删除: 移动n - i -1
    2. i的位置上插入和删除的概率分别为$p_{i}和p_{i}\^{'}$
        1. 插入的平均移动次数为$$M_{i}=\sum_{i=0}\^{n}(n - i)p_{i}$$
        2. 删除的平均移动次数为$$M_{d}=\sum_{i=0}\^{n-1}(n - i - 1)p_{i}\^{'}$$
    3. 如果在顺序表中每个位置上插入和删除元素概率相同,即$$p_{i}=\frac{1}{n+1}, p_{i}\^{'}=\frac{1}{n}$$
        $$
        \begin{align}
        M_{i} &= \frac{1}{n+1}\sum_{i=0}\^{n}(n-i) \\\
              &= \frac{1}{n+1}(\sum_{i=0}\^{n}n-\sum_{i=0}\^{n}i) \\\
              &= \frac{n(n+1)}{n+1}-\frac{n(n+1)}{2(n+1)} \\\
              &= \frac{n}{2} \\\
        M_{d} &= \frac{1}{n}\sum_{i=0}\^{n}(n-i-1) \\\
              &= \frac{1}{n}(\sum_{i=0}\^{n}n-\sum_{i=0}\^{n}i-n) \\\
              &= \frac{n\^2}{n}-\frac{(n-1)}{2}-1 \\\
              &= \frac{n-1}{2}
        \end{align}
        $$
    4. 时间复杂度为O(n)

## 三.链表
> **链表**是通过指针把它的一串存储结点链接成一个链

- 结点组成:
    1. 数据域 + 指针域(后续地址)
- 分类:
    1. 单链表
        1. 简单的单链表
            1. 整个单链表: head
            2. 第一个结点: head
            3. 空表判断: head == NULL
            4. 当前结点$a_{1}$: curr
        2. 带头结点的单链表
            1. 整个单链表: head
            2. 第一个结点: head->next, head $\neq$ NULL
            3. 空表判断: head->next == NULL
            4. 当前结点$a_{1}$: fence->next(curr隐含)
        3. 单链表ADT

        ```cpp
        // 结点类型
        template <class T>
        class Link {
        public:
        T data;
        Link<T> *next;
        Link(const T info, const Link<T> *nextValue = NULL);
        Link(const Link<T> *nextValue);
        };
        template <class T>
        Link::Link(const T info, const Link<T> *nextValue = NULL) : data(info), next(nextValue) {
        }
        template <class T>
        Link::Link(const Link<T> *nextValue) : next(nextValue) {
        }
        // 单链表
        template <class T>
        class LnkList : public List<T> {
        private:
        Link<T> *head, *tail;
        Link<T> *setPos(const int32_t p);
        public:
        LnkList(int32_t s = 0);
        ~LnkList();
        };
        template <class T>
        Link<T>* LnkList<T>::setPos(int32_t i) {
            int32_t count = 0;
            if (i < 0) {
                return head;
            }
            Link<T> *p = head->next;
            while (NULL != p && count < i) {
                ++count;
                p = p->next;
            }
            return p;
        }
        template <class T>
        bool LnkList<T>::insert(const int32_t i, const T value) {
            Link<T> *p, *q;
            if (NULL == (p = setPost(i - 1))) {
                fprintf(stderr, "Insertion point is illegal\n");
                return false;
            }
            Link<T> *q = new Link<T>(value, p->next);
            if (NULL == q) {
                fprintf(stderr, "no memory\n");
                return false;
            }
            p->next = q;
            if (tail == p) {
                tail = q;
            }
            return true;
        }
        template <class T>
        bool LnkList<T>::delete(const int32_t i) {
            Link<T> *p, *q;
            if (NULL == (p = setPost(i - 1))) {
                fprintf(stderr, "Insertion point is illegal\n");
                return false;
            }
            q = p->next;
            p->next = q->next;
            if (tail == q) {
                tail = p;
            }
            delete q;
            return true;
        }
        ```
        4. 时间复杂度分析
            1. 对一个结点操作,必须先找到它,即用一个指针指向它,找单链表中任一结点,都必须从第一个结点开始
            ```
            p = head;
            while (没达到) p = p->next;
            ```
            2. 时间复杂度O(n)
                1. 定位: O(n)
                2. 插入: O(n) + O(1)
                3. 删除: O(n) + O(1)
    2. 双链表
        1. 单链表的next字段仅仅指向后继结点,不能有效的找到前驱结点,反之亦然
        2. 增加一个指向前驱的指针prev
        3. 双链表ADT

        ```cpp
        // 结点类型
        template <class T>
        class Link {
        public:
        T data;
        Link<T> *next;
        Link<T> *prev;
        Link(const T info, Link<T> *preValue = NULL, Link<T> *nextValue = NULL);
        Link(Link<T> *preValue = NULL, Link<T> *nextValue = NULL);
        };
        template <class T>
        Link::Link(const T info, Link<T> *preValue, Link<T> *nextValue) : data(info), next(nextValue), prev(preValue) {
        }
        template <class T>
        Link::Link(Link<T> *preValue, Link<T> *nextValue) : next(nextValue), prev(preValue) {
        }
        // 双链表
        template <class T>
        class DLnkList : public List<T> {
        private:
        Link<T> *head, *tail;
        Link<T> *setPos(const int32_t p);
        public:
        LnkList(int32_t s = 0);
        ~LnkList();
        };
        template <class T>
        Link<T>* DLnkList<T>::setPos(int32_t i) {
            int32_t count = 0;
            if (i < 0) {
                return head;
            }
            Link<T> *p = head->next;
            while (NULL != p && count < i) {
                ++count;
                p = p->next;
            }
            return p;
        }
        template <class T>
        bool DLnkList<T>::insert(const int32_t i, const T value) {
            Link<T> *p, *q;
            if (NULL == (p = setPost(i - 1))) {
                fprintf(stderr, "Insertion point is illegal\n");
                return false;
            }
            Link<T> *q = new Link<T>(value, p, p->next);
            if (NULL == q) {
                fprintf(stderr, "no memory\n");
                return false;
            }
            p->next = q;
            if (tail == p) {
                tail = q;
            } else {
                q->next->prev = q;
            }
            return true;
        }
        template <class T>
        bool LnkList<T>::delete(const int32_t i) {
            Link<T> *p;
            if (NULL == (p = setPost(i))) {
                fprintf(stderr, "Insertion point is illegal\n");
                return false;
            }
            p->prev->next = p->next;
            p->next->prev = p->prev;
            if (tail == p) {
                tail = p->prev;
            }
            p->next = NULL;
            p->prev = NULL;
            delete q;
            return true;
        }

        ```
    3. 循环链表
        1. 将单链表或者双链表的头尾结点链接起来,就是一个循环链表
        2. 从循环链表中任意结点出发,都能访问到表中其他结点
    4. 链表的边界条件
        1. 头指针处理
        2. 非循环链表尾结点的指针域保持为NULL
        3. 循环链表尾结点的指针回指头结点
        4. 空链表的特殊处理
        5. 插入或删除结点时指针勾链的顺序
        6. 指针移到的正确性

## 四.顺序表和链表的比较
||顺序表|链表|
|---|---|---|
|优点|1. 没有使用指针,不用花费额外开销<br>2. 线性表元素的读访问非常简洁便利<br>3. 是存储静态数据的不二选择|1. 无需事先了解线性表的长度<br>2. 允许线性表的长度动态变化<br>3. 能够适应经常插入删除内部元素的情况<br>4. 是存储动态变化数据的良方|
|算法复杂度|1. 插入,删除运算时间复杂度为O(n),查找为O(1)<br>2. 需要预先申请固定长度的连续空间<br>3. 如果整个数组元素很满,则没有结构性存储开销|1. 插入,删除运算时间复杂度为O(1),查找为O(n)<br>2. 存储利用指针,动态的按照需要为表中新的元素分配存储空间<br>3. 每个元素都有结构性存储开销|
|不适用场合|1. 经常插入,删除<br>2.不能预留合适空间|1.频繁查找操作,即查找操作比插入和删除操作频率大时<br>2. 当指针的存储开销和整个结点内容所占空间相比其比例较大时|
|适合场景|1. 结点数大概可以估计<br>2. 结点比较稳定,即插入和删除较少|1. 结点数无法预知<br>2. 结点动态变化,即插入和删除较多|
